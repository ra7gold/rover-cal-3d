<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rover Calibration 3D Visualizer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e; 
            color: #eee;
            overflow: hidden;
        }
        #container { width: 100vw; height: 100vh; }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            width: 280px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        h2 { 
            font-size: 16px; 
            margin-bottom: 10px; 
            color: #4ecdc4;
            border-bottom: 1px solid #4ecdc4;
            padding-bottom: 5px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        label {
            flex: 1;
            font-size: 12px;
            color: #aaa;
        }
        
        input[type="range"] {
            width: 100px;
            margin: 0 10px;
        }
        
        .value {
            width: 50px;
            text-align: right;
            font-family: monospace;
            font-size: 12px;
            color: #4ecdc4;
        }
        
        #results {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            width: 220px;
        }
        
        .result-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 13px;
        }
        
        .result-label { color: #aaa; }
        .result-value { 
            font-family: monospace; 
            font-weight: bold;
        }
        .pass { color: #4ecdc4; }
        .warn { color: #f9ca24; }
        .fail { color: #ff6b6b; }
        
        #legend {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 12px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 3px 0;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        #instructions {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.6);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 11px;
            color: #888;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="controls">
        <h2>üìê Machine Orientation</h2>
        <div class="control-group">
            <div class="control-row">
                <label>Yaw (¬∞)</label>
                <input type="range" id="yaw" min="-45" max="45" value="0" step="0.5">
                <span class="value" id="yawVal">0.0</span>
            </div>
            <div class="control-row">
                <label>Pitch (¬∞)</label>
                <input type="range" id="pitch" min="-10" max="10" value="0" step="0.5">
                <span class="value" id="pitchVal">0.0</span>
            </div>
            <div class="control-row">
                <label>Roll (¬∞)</label>
                <input type="range" id="roll" min="-10" max="10" value="0" step="0.5">
                <span class="value" id="rollVal">0.0</span>
            </div>
        </div>
        
        <h2>üõ∞Ô∏è Rover Mount</h2>
        <div class="control-group">
            <div class="control-row">
                <label>Mount X (ft)</label>
                <input type="range" id="mountX" min="-4" max="0" value="-3" step="1">
                <span class="value" id="mountXVal">-3</span>
            </div>
        </div>
        
        <h2>üì° Antenna Offsets</h2>
        <div class="control-group">
            <div class="control-row">
                <label>X fwd (ft)</label>
                <input type="range" id="antX" min="-2" max="4" value="1.6" step="0.1">
                <span class="value" id="antXVal">1.6</span>
            </div>
            <div class="control-row">
                <label>Y right (ft)</label>
                <input type="range" id="antY" min="0" max="8" value="5.4" step="0.1">
                <span class="value" id="antYVal">5.4</span>
            </div>
            <div class="control-row">
                <label>Z down (ft)</label>
                <input type="range" id="antZ" min="0" max="10" value="6.6" step="0.1">
                <span class="value" id="antZVal">6.6</span>
            </div>
        </div>
        
        <h2>üéØ Target Point</h2>
        <div class="control-group">
            <div class="control-row">
                <label>Offset N (ft)</label>
                <input type="range" id="targetN" min="-5" max="5" value="0" step="0.1">
                <span class="value" id="targetNVal">0.0</span>
            </div>
            <div class="control-row">
                <label>Offset E (ft)</label>
                <input type="range" id="targetE" min="-5" max="5" value="0" step="0.1">
                <span class="value" id="targetEVal">0.0</span>
            </div>
        </div>
    </div>
    
    <div id="results">
        <h2>üìä QC Results</h2>
        <div class="result-row">
            <span class="result-label">N Error:</span>
            <span class="result-value" id="errN">0.0 mm</span>
        </div>
        <div class="result-row">
            <span class="result-label">E Error:</span>
            <span class="result-value" id="errE">0.0 mm</span>
        </div>
        <div class="result-row">
            <span class="result-label">Z Error:</span>
            <span class="result-value" id="errZ">0.0 mm</span>
        </div>
        <div class="result-row" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #333;">
            <span class="result-label">Horiz:</span>
            <span class="result-value" id="errH">0.0 mm</span>
        </div>
        <div class="result-row">
            <span class="result-label">Status:</span>
            <span class="result-value" id="status">‚úÖ PASS</span>
        </div>
    </div>
    
    <div id="legend">
        <div class="legend-item"><div class="legend-color" style="background:#4ecdc4"></div>Work Point (WP)</div>
        <div class="legend-item"><div class="legend-color" style="background:#ff6b6b"></div>Machine Antenna</div>
        <div class="legend-item"><div class="legend-color" style="background:#f9ca24"></div>Rover (on mount)</div>
        <div class="legend-item"><div class="legend-color" style="background:#a55eea"></div>Target Point</div>
        <div class="legend-item"><div class="legend-color" style="background:#26de81"></div>Computed WP</div>
    </div>
    
    <div id="instructions">
        üñ±Ô∏è Drag to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ Right-drag to pan
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 12, 15);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('container').appendChild(renderer.domElement);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);
        
        // Ground grid
        const gridHelper = new THREE.GridHelper(30, 30, 0x444444, 0x333333);
        scene.add(gridHelper);
        
        // Axis labels
        function createAxisLabel(text, position, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.font = 'bold 24px Arial';
            ctx.fillText(text, 10, 24);
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.position.copy(position);
            sprite.scale.set(2, 1, 1);
            return sprite;
        }
        
        // World axes
        const worldAxes = new THREE.AxesHelper(8);
        scene.add(worldAxes);
        scene.add(createAxisLabel('N', new THREE.Vector3(9, 0, 0), '#ff4444'));
        scene.add(createAxisLabel('E', new THREE.Vector3(0, 0, 9), '#44ff44'));
        scene.add(createAxisLabel('Up', new THREE.Vector3(0, 9, 0), '#4444ff'));
        
        // Create objects
        // Work Point
        const wpGeom = new THREE.SphereGeometry(0.3, 32, 32);
        const wpMat = new THREE.MeshPhongMaterial({ color: 0x4ecdc4, emissive: 0x4ecdc4, emissiveIntensity: 0.3 });
        const workPoint = new THREE.Mesh(wpGeom, wpMat);
        scene.add(workPoint);
        
        // Machine body (simple box)
        const machineGroup = new THREE.Group();
        const bodyGeom = new THREE.BoxGeometry(4, 1, 2);
        const bodyMat = new THREE.MeshPhongMaterial({ color: 0x666666, transparent: true, opacity: 0.7 });
        const machineBody = new THREE.Mesh(bodyGeom, bodyMat);
        machineBody.position.y = 0.5;
        machineGroup.add(machineBody);
        
        // Machine local axes
        const machineAxes = new THREE.AxesHelper(3);
        machineGroup.add(machineAxes);
        
        // Machine antenna
        const antGeom = new THREE.SphereGeometry(0.25, 32, 32);
        const antMat = new THREE.MeshPhongMaterial({ color: 0xff6b6b, emissive: 0xff6b6b, emissiveIntensity: 0.3 });
        const antenna = new THREE.Mesh(antGeom, antMat);
        machineGroup.add(antenna);
        
        // Antenna pole
        const poleGeom = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
        const poleMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
        const antennaPole = new THREE.Mesh(poleGeom, poleMat);
        machineGroup.add(antennaPole);
        
        scene.add(machineGroup);
        
        // Rover
        const roverGeom = new THREE.SphereGeometry(0.2, 32, 32);
        const roverMat = new THREE.MeshPhongMaterial({ color: 0xf9ca24, emissive: 0xf9ca24, emissiveIntensity: 0.3 });
        const rover = new THREE.Mesh(roverGeom, roverMat);
        scene.add(rover);
        
        // Rover pole
        const roverPoleGeom = new THREE.CylinderGeometry(0.03, 0.03, 2, 8);
        const roverPole = new THREE.Mesh(roverPoleGeom, poleMat);
        scene.add(roverPole);
        
        // Target point
        const targetGeom = new THREE.OctahedronGeometry(0.3);
        const targetMat = new THREE.MeshPhongMaterial({ color: 0xa55eea, emissive: 0xa55eea, emissiveIntensity: 0.3 });
        const target = new THREE.Mesh(targetGeom, targetMat);
        scene.add(target);
        
        // Computed WP from rover
        const computedWPGeom = new THREE.SphereGeometry(0.2, 32, 32);
        const computedWPMat = new THREE.MeshPhongMaterial({ color: 0x26de81, emissive: 0x26de81, emissiveIntensity: 0.3, wireframe: true });
        const computedWP = new THREE.Mesh(computedWPGeom, computedWPMat);
        scene.add(computedWP);
        
        // Error line
        const errorLineMat = new THREE.LineBasicMaterial({ color: 0xff6b6b });
        const errorLineGeom = new THREE.BufferGeometry();
        const errorLine = new THREE.Line(errorLineGeom, errorLineMat);
        scene.add(errorLine);
        
        // Connection lines
        const lineMat = new THREE.LineDashedMaterial({ color: 0x666666, dashSize: 0.2, gapSize: 0.1 });
        
        function createLine() {
            const geom = new THREE.BufferGeometry();
            const line = new THREE.Line(geom, lineMat);
            line.computeLineDistances();
            return line;
        }
        
        const wpToAntLine = createLine();
        scene.add(wpToAntLine);
        const wpToRoverLine = createLine();
        scene.add(wpToRoverLine);
        
        // Update function
        function updateScene() {
            const yaw = parseFloat(document.getElementById('yaw').value);
            const pitch = parseFloat(document.getElementById('pitch').value);
            const roll = parseFloat(document.getElementById('roll').value);
            const mountX = parseFloat(document.getElementById('mountX').value);
            const antX = parseFloat(document.getElementById('antX').value);
            const antY = parseFloat(document.getElementById('antY').value);
            const antZ = parseFloat(document.getElementById('antZ').value);
            const targetN = parseFloat(document.getElementById('targetN').value);
            const targetE = parseFloat(document.getElementById('targetE').value);
            
            // Update display values
            document.getElementById('yawVal').textContent = yaw.toFixed(1);
            document.getElementById('pitchVal').textContent = pitch.toFixed(1);
            document.getElementById('rollVal').textContent = roll.toFixed(1);
            document.getElementById('mountXVal').textContent = mountX.toFixed(0);
            document.getElementById('antXVal').textContent = antX.toFixed(1);
            document.getElementById('antYVal').textContent = antY.toFixed(1);
            document.getElementById('antZVal').textContent = antZ.toFixed(1);
            document.getElementById('targetNVal').textContent = targetN.toFixed(1);
            document.getElementById('targetEVal').textContent = targetE.toFixed(1);
            
            // Convert to radians
            const yawRad = THREE.MathUtils.degToRad(yaw);
            const pitchRad = THREE.MathUtils.degToRad(pitch);
            const rollRad = THREE.MathUtils.degToRad(roll);
            
            // Update machine orientation (note: Three.js Y is up)
            // Our convention: X=North, Z=East, Y=Up
            machineGroup.rotation.set(0, 0, 0);
            machineGroup.rotateY(-yawRad);  // Yaw around Y (up)
            machineGroup.rotateX(pitchRad); // Pitch around X
            machineGroup.rotateZ(-rollRad); // Roll around Z
            
            // Antenna position in body frame, then transform
            // Body: X=forward, Y=right, Z=down -> World: X=North, Z=East, Y=Up
            const antBody = new THREE.Vector3(antX, -antZ, antY);
            antenna.position.copy(antBody);
            antennaPole.position.set(antBody.x, antBody.y + 0.5, antBody.z);
            
            // Rover position in body frame
            const roverBody = new THREE.Vector3(mountX, 0, 0);
            
            // Get world positions
            const antWorld = antenna.getWorldPosition(new THREE.Vector3());
            const roverWorld = new THREE.Vector3();
            machineGroup.localToWorld(roverWorld.copy(roverBody));
            
            // Update rover mesh
            rover.position.copy(roverWorld);
            roverPole.position.set(roverWorld.x, roverWorld.y + 1, roverWorld.z);
            
            // Target position
            target.position.set(targetN, 0, targetE);
            
            // Compute WP from rover reading
            // WP_N = Rover_N + mountX * cos(yaw)
            // WP_E = Rover_E - mountX * sin(yaw)
            const computedN = roverWorld.x + mountX * Math.cos(-yawRad);
            const computedE = roverWorld.z - mountX * Math.sin(-yawRad);
            computedWP.position.set(computedN, 0, computedE);
            
            // Calculate errors (compared to target, in mm)
            const errN = (computedN - targetN) * 304.8;
            const errE = (computedE - targetE) * 304.8;
            const errZ = 0; // Simplified for now
            const errH = Math.sqrt(errN*errN + errE*errE);
            
            // Update results
            document.getElementById('errN').textContent = errN.toFixed(1) + ' mm';
            document.getElementById('errE').textContent = errE.toFixed(1) + ' mm';
            document.getElementById('errZ').textContent = errZ.toFixed(1) + ' mm';
            document.getElementById('errH').textContent = errH.toFixed(1) + ' mm';
            
            // Color code results
            const colorClass = (val, threshGood, threshWarn) => {
                if (Math.abs(val) <= threshGood) return 'pass';
                if (Math.abs(val) <= threshWarn) return 'warn';
                return 'fail';
            };
            
            document.getElementById('errN').className = 'result-value ' + colorClass(errN, 10, 25);
            document.getElementById('errE').className = 'result-value ' + colorClass(errE, 10, 25);
            document.getElementById('errH').className = 'result-value ' + colorClass(errH, 15, 30);
            
            // Status
            const statusEl = document.getElementById('status');
            if (errH <= 15) {
                statusEl.textContent = '‚úÖ PASS';
                statusEl.className = 'result-value pass';
            } else if (errH <= 30) {
                statusEl.textContent = '‚ö†Ô∏è CHECK';
                statusEl.className = 'result-value warn';
            } else {
                statusEl.textContent = '‚ùå RECAL';
                statusEl.className = 'result-value fail';
            }
            
            // Update connection lines
            updateLine(wpToAntLine, [workPoint.position, antWorld]);
            updateLine(wpToRoverLine, [workPoint.position, roverWorld]);
            updateLine(errorLine, [computedWP.position, target.position]);
        }
        
        function updateLine(line, points) {
            const positions = new Float32Array(points.length * 3);
            points.forEach((p, i) => {
                positions[i*3] = p.x;
                positions[i*3+1] = p.y;
                positions[i*3+2] = p.z;
            });
            line.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            line.geometry.attributes.position.needsUpdate = true;
            line.computeLineDistances();
        }
        
        // Event listeners
        document.querySelectorAll('input[type="range"]').forEach(input => {
            input.addEventListener('input', updateScene);
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initial update
        updateScene();
        animate();
    </script>
</body>
</html>
